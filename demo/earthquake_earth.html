<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Earth - Real-time Earthquakes</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            max-width: 320px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        #info h1 {
            font-size: 20px;
            margin-bottom: 10px;
            color: #00d4ff;
        }
        #info p {
            font-size: 13px;
            line-height: 1.6;
            color: #ccc;
            margin-bottom: 8px;
        }
        #earthquake-list {
            margin-top: 15px;
            max-height: 300px;
            overflow-y: auto;
        }
        .quake-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 5px;
            border-left: 3px solid #00d4ff;
            font-size: 12px;
        }
        .quake-item strong {
            color: #ff6b6b;
            font-size: 14px;
        }
        .quake-item .location {
            color: #fff;
            margin-top: 5px;
        }
        .quake-item .time {
            color: #888;
            font-size: 11px;
            margin-top: 3px;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00d4ff;
            font-size: 24px;
            text-align: center;
        }
        .legend {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            font-size: 12px;
        }
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        ::-webkit-scrollbar {
            width: 6px;
        }
        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
        }
        ::-webkit-scrollbar-thumb {
            background: rgba(0, 212, 255, 0.5);
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="loading">Loading Earth...</div>
    <div id="info">
        <h1>üåç 3D Earth - Real-time Earthquakes</h1>
        <p>Displaying recent earthquakes from USGS (past 7 days)</p>
        <p><strong>Left click + drag:</strong> Rotate | <strong>Scroll:</strong> Zoom</p>
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #ff0000;"></div>
                <span>Magnitude 7.0+ (Major)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ff6600;"></div>
                <span>Magnitude 6.0-6.9 (Strong)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ffcc00;"></div>
                <span>Magnitude 5.0-5.9 (Moderate)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #00ff00;"></div>
                <span>Magnitude 4.0-4.9 (Light)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #00ccff;"></div>
                <span>Magnitude &lt; 4.0 (Minor)</span>
            </div>
        </div>
        <div id="earthquake-list"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Camera position
        camera.position.z = 3.5;

        // Controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 1.5;
        controls.maxDistance = 10;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x333333, 1.5);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
        sunLight.position.set(5, 3, 5);
        scene.add(sunLight);

        // Starfield
        function createStarfield() {
            const starsGeometry = new THREE.BufferGeometry();
            const starsCount = 3000;
            const posArray = new Float32Array(starsCount * 3);
            const colorArray = new Float32Array(starsCount * 3);

            for(let i = 0; i < starsCount * 3; i += 3) {
                // Spherical distribution
                const radius = 50 + Math.random() * 50;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);

                posArray[i] = radius * Math.sin(phi) * Math.cos(theta);
                posArray[i+1] = radius * Math.sin(phi) * Math.sin(theta);
                posArray[i+2] = radius * Math.cos(phi);

                // Star colors (blue-ish to white)
                const colorChoice = Math.random();
                if (colorChoice > 0.8) {
                    colorArray[i] = 0.8;     // R
                    colorArray[i+1] = 0.8;   // G
                    colorArray[i+2] = 1.0;   // B (blue-ish)
                } else {
                    colorArray[i] = 1.0;     // R
                    colorArray[i+1] = 1.0;   // G
                    colorArray[i+2] = 1.0;   // B (white)
                }
            }

            starsGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            starsGeometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));

            const starsMaterial = new THREE.PointsMaterial({
                size: 0.15,
                vertexColors: true,
                transparent: true,
                opacity: 0.8
            });

            return new THREE.Points(starsGeometry, starsMaterial);
        }
        scene.add(createStarfield());

        // Earth sphere
        const earthGeometry = new THREE.SphereGeometry(1, 64, 64);
        const earthMaterial = new THREE.MeshPhongMaterial({
            color: 0xffffff,
            emissive: 0x112244,
            emissiveIntensity: 0.1,
            shininess: 10
        });
        const earth = new THREE.Mesh(earthGeometry, earthMaterial);
        scene.add(earth);

        // Atmosphere glow
        const atmosphereGeometry = new THREE.SphereGeometry(1.05, 64, 64);
        const atmosphereMaterial = new THREE.MeshPhongMaterial({
            color: 0x00aaff,
            transparent: true,
            opacity: 0.15,
            side: THREE.BackSide
        });
        const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
        scene.add(atmosphere);

        // Earth texture loader
        const textureLoader = new THREE.TextureLoader();
        textureLoader.load(
            'https://unpkg.com/three-globe@2.24.13/example/img/earth-blue-marble.jpg',
            function(texture) {
                earthMaterial.map = texture;
                earthMaterial.needsUpdate = true;
                document.getElementById('loading').style.display = 'none';
            },
            undefined,
            function(err) {
                // Fallback to a simple color if texture fails
                earthMaterial.color.setHex(0x1a5276);
                document.getElementById('loading').style.display = 'none';
            }
        );

        // Load bump map
        textureLoader.load(
            'https://unpkg.com/three-globe@2.24.13/example/img/earth-topology.png',
            function(texture) {
                earthMaterial.bumpMap = texture;
                earthMaterial.bumpScale = 0.05;
                earthMaterial.needsUpdate = true;
            }
        );

        // Earthquake markers
        const earthquakeGroup = new THREE.Group();
        earth.add(earthquakeGroup);

        function getColorByMagnitude(mag) {
            if (mag >= 7.0) return 0xff0000;
            if (mag >= 6.0) return 0xff6600;
            if (mag >= 5.0) return 0xffcc00;
            if (mag >= 4.0) return 0x00ff00;
            return 0x00ccff;
        }

        function getSizeByMagnitude(mag) {
            if (mag >= 7.0) return 0.06;
            if (mag >= 6.0) return 0.045;
            if (mag >= 5.0) return 0.035;
            if (mag >= 4.0) return 0.025;
            return 0.015;
        }

        function latLonToVector3(lat, lon, radius) {
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lon + 180) * (Math.PI / 180);
            const x = -(radius * Math.sin(phi) * Math.cos(theta));
            const z = (radius * Math.sin(phi) * Math.sin(theta));
            const y = (radius * Math.cos(phi));
            return new THREE.Vector3(x, y, z);
        }

        function createEarthquakeMarker(quake) {
            const mag = quake.properties.mag;
            const color = getColorByMagnitude(mag);
            const size = getSizeByMagnitude(mag);

            // Marker group
            const markerGroup = new THREE.Group();

            // Main marker
            const geometry = new THREE.SphereGeometry(size, 16, 16);
            const material = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.9
            });
            const marker = new THREE.Mesh(geometry, material);
            markerGroup.add(marker);

            // Glow effect
            const glowGeometry = new THREE.SphereGeometry(size * 2, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.3
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            markerGroup.add(glow);

            // Pulse ring for larger earthquakes
            if (mag >= 5.0) {
                const ringGeometry = new THREE.RingGeometry(size * 2, size * 2.5, 32);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.5,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.lookAt(new THREE.Vector3(0, 0, 0));
                markerGroup.add(ring);
                markerGroup.userData.ring = ring;
            }

            // Position on Earth surface
            const coords = quake.geometry.coordinates;
            const position = latLonToVector3(coords[1], coords[0], 1.02);
            markerGroup.position.copy(position);
            markerGroup.lookAt(new THREE.Vector3(0, 0, 0));

            // Store earthquake data
            markerGroup.userData.quake = quake;
            markerGroup.userData.glow = glow;

            return markerGroup;
        }

        async function fetchEarthquakes() {
            try {
                const response = await fetch(
                    'https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_week.geojson'
                );
                const data = await response.json();
                return data.features;
            } catch (error) {
                console.error('Failed to fetch earthquake data:', error);
                return [];
            }
        }

        function formatTime(timestamp) {
            const date = new Date(timestamp);
            return date.toLocaleString('zh-CN');
        }

        function updateEarthquakeList(quakes) {
            const listContainer = document.getElementById('earthquake-list');
            const topQuakes = quakes
                .filter(q => q.properties.mag >= 4.0)
                .sort((a, b) => b.properties.mag - a.properties.mag)
                .slice(0, 10);

            let html = '<h3 style="color: #00d4ff; margin-bottom: 10px;">Recent Significant Earthquakes</h3>';
            topQuakes.forEach(quake => {
                const mag = quake.properties.mag.toFixed(1);
                const place = quake.properties.place;
                const time = formatTime(quake.properties.time);
                html += `
                    <div class="quake-item">
                        <strong>M ${mag}</strong>
                        <div class="location">${place}</div>
                        <div class="time">${time}</div>
                    </div>
                `;
            });
            listContainer.innerHTML = html;
        }

        async function init() {
            const earthquakes = await fetchEarthquakes();
            console.log(`Loaded ${earthquakes.length} earthquakes`);

            // Add markers for all earthquakes with magnitude >= 2.5
            earthquakes
                .filter(q => q.properties.mag >= 2.5)
                .forEach(quake => {
                    const marker = createEarthquakeMarker(quake);
                    earthquakeGroup.add(marker);
                });

            updateEarthquakeList(earthquakes);
        }

        init();

        // Animation loop
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            controls.update();

            // Animate earthquake markers
            earthquakeGroup.children.forEach(marker => {
                // Pulse effect
                const glow = marker.userData.glow;
                if (glow) {
                    const scale = 1 + Math.sin(time * 3) * 0.2;
                    glow.scale.set(scale, scale, scale);
                }

                // Ring rotation for larger quakes
                const ring = marker.userData.ring;
                if (ring) {
                    const scale = 1 + Math.sin(time * 2) * 0.3;
                    ring.scale.set(scale, scale, 1);
                    ring.material.opacity = 0.3 + Math.sin(time * 2) * 0.2;
                }
            });

            // Subtle atmosphere pulse
            const atmoScale = 1 + Math.sin(time * 0.5) * 0.005;
            atmosphere.scale.set(atmoScale, atmoScale, atmoScale);

            renderer.render(scene, camera);
        }
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Raycaster for mouse interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(earthquakeGroup.children, true);

            if (intersects.length > 0) {
                document.body.style.cursor = 'pointer';
                const quake = intersects[0].object.parent.userData.quake;
                if (quake) {
                    controls.autoRotate = false;
                }
            } else {
                document.body.style.cursor = 'default';
                controls.autoRotate = true;
            }
        });
    </script>
</body>
</html>
